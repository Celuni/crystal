/*
 * 
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct TracingApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> TracingApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> TracingApiClient<C> {
        TracingApiClient {
            configuration,
        }
    }
}

pub trait TracingApi {
    fn delete_tracing_v1_trace_time_series_event_by_event_name(&self, event_name: &str, when: i64, suffix: Option<&str>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn post_tracing_v1_trace_event(&self, tracing_event: crate::models::TracingEventV1) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn post_tracing_v1_trace_module(&self, module: crate::models::TracingModuleV1) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn post_tracing_v1_trace_phase_begin(&self, phase_begin: crate::models::TracingPhaseBeginV1) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn post_tracing_v1_trace_phase_end(&self, phase_end: crate::models::TracingPhaseEndV1) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn post_tracing_v1_trace_time_series_event_by_event_name(&self, event_name: &str, when: i64) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn post_tracing_v1_trace_time_series_event_by_event_name_marker_by_marker_name(&self, event_name: &str, marker_name: &str, when: i64) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
}

impl<C: hyper::client::Connect>TracingApi for TracingApiClient<C> {
    fn delete_tracing_v1_trace_time_series_event_by_event_name(&self, event_name: &str, when: i64, suffix: Option<&str>) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/tracing/v1/trace/time-series-event/{eventName}".to_string())
        ;
        req = req.with_query_param("when".to_string(), when.to_string());
        if let Some(ref s) = suffix {
            req = req.with_query_param("suffix".to_string(), s.to_string());
        }
        req = req.with_path_param("eventName".to_string(), event_name.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn post_tracing_v1_trace_event(&self, tracing_event: crate::models::TracingEventV1) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/tracing/v1/trace/event".to_string())
        ;
        req = req.with_body_param(tracing_event);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn post_tracing_v1_trace_module(&self, module: crate::models::TracingModuleV1) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/tracing/v1/trace/module".to_string())
        ;
        req = req.with_body_param(module);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn post_tracing_v1_trace_phase_begin(&self, phase_begin: crate::models::TracingPhaseBeginV1) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/tracing/v1/trace/phase/begin".to_string())
        ;
        req = req.with_body_param(phase_begin);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn post_tracing_v1_trace_phase_end(&self, phase_end: crate::models::TracingPhaseEndV1) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/tracing/v1/trace/phase/end".to_string())
        ;
        req = req.with_body_param(phase_end);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn post_tracing_v1_trace_time_series_event_by_event_name(&self, event_name: &str, when: i64) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/tracing/v1/trace/time-series-event/{eventName}".to_string())
        ;
        req = req.with_path_param("eventName".to_string(), event_name.to_string());
        req = req.with_body_param(when);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn post_tracing_v1_trace_time_series_event_by_event_name_marker_by_marker_name(&self, event_name: &str, marker_name: &str, when: i64) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/tracing/v1/trace/time-series-event/{eventName}/marker/{markerName}".to_string())
        ;
        req = req.with_path_param("eventName".to_string(), event_name.to_string());
        req = req.with_path_param("markerName".to_string(), marker_name.to_string());
        req = req.with_body_param(when);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

}
